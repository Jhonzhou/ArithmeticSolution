### 两数之和(1)

题目描述：

&emsp;&emsp;给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标

[解题源码](_1_TheSumOfTwoNumbers.java)
### 两数平方和()
题目描述：

&emsp;&emsp;判断一个数是否为两个数的平方和。
[解题源码](SumOfSquareNumbers.java)
### 两数相加(2)
题目描述 ：

&emsp;&emsp;给出两个 非空 的链表用来表示两个非负的整数。其中，它们各自的位数是按照 逆序 的方式存储的，并且它们的每个节点只能存储 一位 数字。如果，我们将这两个数相加起来，则会返回一个新的链表来表示它们的和。您可以假设除了数字 0 之外，这两个数都不会以 0 开头
[解题源码](_2_TwoNumberSum.java)
### 无重复字符的最长子串(3)
题目描述：

&emsp;&emsp;给定一个字符串，请你找出其中不含有重复字符的 最长子串 的长度
[解题源码](_3_FindTheLongerNoRepeatStringLength.java)
### 寻找两个有序数组的中位数(4)
题目描述：

&emsp;&emsp;给定两个大小为 m 和 n 的有序数组 nums1 和 nums2。
请你找出这两个有序数组的中位数，并且要求算法的时间复杂度为 O(log(m + n))。
你可以假设 nums1 和 nums2 不会同时为空。

Related Topics 数组 二分查找 分治算法
[解题源码](_4_FindMedianSortedArrays.java)
### 最长回文子串(5)
题目描述：

&emsp;&emsp;给定一个字符串 s，找到 s 中最长的回文子串。你可以假设 s 的最大长度为 1000
// Related Topics 字符串 动态规划
[解题源码](_5_LongestPalindrome.java)
### 最长子序列(524)
题目描述：

&emsp;&emsp;给定一个字符串和一个字符串字典，找到字典里面最长的字符串，该字符串可以通过删除给定字符串的某些字符来得到。如果答案不止一个，返回长度最长且字典顺序最小的字符串。如果答案不存在，则返回空字符串
[解题源码](FindLongestWord.java)
### Z 字形变换(6)
题目描述：

&emsp;&emsp;将一个给定字符串根据给定的行数，以从上往下、从左到右进行 Z 字形排列。
Related Topics 字符串
[解题源码](_6_ZStringConvert.java)
### 整数反转(7)
题目描述：

&emsp;&emsp;给出一个 32 位的有符号整数，你需要将这个整数中每位上的数字进行反转
[解题源码](_7_ReverseInt.java)
### 字符串转换整数 (atoi)(8)
题目描述：

&emsp;&emsp;请你来实现一个 atoi 函数，使其能将字符串转换成整数。
[解题源码](_8_StringToInt.java)
### 回文数(9)
题目描述：

&emsp;&emsp;判断一个整数是否是回文数。回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数
[解题源码](_9_PalindromeInt.java)
### 10. 正则表达式匹配
题目描述：

&emsp;&emsp;给你一个字符串 s 和一个字符规律 p，请你来实现一个支持 '.' 和 '*' 的正则表达式匹配。
所谓匹配，是要涵盖 整个 字符串 s的，而不是部分字符串。
说明:

    '.' 匹配任意单个字符
    '*' 匹配零个或多个前面的那一个元素

    s 可能为空，且只包含从 a-z 的小写字母。
    p 可能为空，且只包含从 a-z 的小写字母，以及字符 . 和 *。

[解题源码](_10_TwoStringIsMatch.java)
### 11. 盛最多水的容器
题目描述：

&emsp;&emsp;  给你 n 个非负整数 a1，a2，...，an，每个数代表坐标中的一个点 (i, ai) 。在坐标内画 n 条垂直线，垂直线 i 的两个端点分别为 (i,
ai) 和 (i, 0)。找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。

 说明：你不能倾斜容器，且 n 的值至少为 2。
 图中垂直线代表输入数组 [1,8,6,2,5,4,8,3,7]。在此情况下，容器能够容纳水（表示为蓝色部分）的最大值为 49。
 示例：

 输入：[1,8,6,2,5,4,8,3,7]
输出：49
 Related Topics 数组 双指针
[解题源码](_11_ContainerWithMostWater.java)
### 12. 整数转罗马数字
题目描述：

&emsp;&emsp;罗马数字包含以下七种字符： I， V， X， L，C，D 和 M。

字符          数值
I             1
V             5
X             10
L             50
C             100
D             500
M             1000
例如， 罗马数字 2 写做 II ，即为两个并列的 1。12 写做 XII ，即为 X + II 。 27 写做  XXVII, 即为 XX + V + II 。

通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做 IIII，而是 IV。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为 IX。这个特殊的规则只适用于以下六种情况：

I 可以放在 V (5) 和 X (10) 的左边，来表示 4 和 9。
X 可以放在 L (50) 和 C (100) 的左边，来表示 40 和 90。 
C 可以放在 D (500) 和 M (1000) 的左边，来表示 400 和 900。
给定一个整数，将其转为罗马数字。输入确保在 1 到 3999 的范围内。
[解题源码](_12_IntToRoman.java)
### 13. 罗马数字转整数
题目描述：

&emsp;&emsp;罗马数字包含以下七种字符： I， V， X， L，C，D 和 M。

字符          数值
I             1
V             5
X             10
L             50
C             100
D             500
M             1000
例如， 罗马数字 2 写做 II ，即为两个并列的 1。12 写做 XII ，即为 X + II 。 27 写做  XXVII, 即为 XX + V + II 。

通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做 IIII，而是 IV。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为 IX。这个特殊的规则只适用于以下六种情况：

I 可以放在 V (5) 和 X (10) 的左边，来表示 4 和 9。
X 可以放在 L (50) 和 C (100) 的左边，来表示 40 和 90。 
C 可以放在 D (500) 和 M (1000) 的左边，来表示 400 和 900。
给定一个整数，将其转为罗马数字。输入确保在 1 到 3999 的范围内。
[解题源码](_13_RomanToInt.java)
### 14. 最长公共前缀
题目描述：

&emsp;&emsp;编写一个函数来查找字符串数组中的最长公共前缀。如果不存在公共前缀，返回空字符串 ""
[解题源码](_14_LongestCommonPrefix.java)
### 15. 三数之和
题目描述：

&emsp;&emsp;给定一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？找出所有满足条件且不重复的三元组。
注意：答案中不可以包含重复的三元组。
[解题源码](_15_ThreeSum.java)
### 16. 最接近的三数之和
题目描述：

&emsp;&emsp;给定一个包括 n 个整数的数组 nums 和 一个目标值 target。找出 nums 中的三个整数，使得它们的和与 target 最接近。返回这三个数的和。假定每组输入只存在唯一答案。

    例如，给定数组 nums = [-1，2，1，-4], 和 target = 1.
    与 target 最接近的三个数的和为 2. (-1 + 2 + 1 = 2).
[解题源码](_16_ThreeSumClosest.java)
### 17. 电话号码的字母组合
题目描述：

&emsp;&emsp;给定一个仅包含数字 2-9 的字符串，返回所有它能表示的字母组合。
            给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。

    输入："23"
    输出：["ad", "ae", "af", "bd", "be", "bf", "cd", "ce", "cf"].
 说明:
    尽管上面的答案是按字典序排列的，但是你可以任意选择答案输出的顺序。
[解题源码](LetterCombinations.java)
### 18. 四数之和
题目描述：

&emsp;&emsp;给定一个包含 n 个整数的数组 nums 和一个目标值 target，判断 nums 中是否存在四个元素 a，b，c 和 d ，使得 a + b + c + d 的值与 target 相等？找出所有满足条件且不重复的四元组。

    注意：
    答案中不可以包含重复的四元组。
[解题源码](FourSum.java)
### 19. 删除链表的倒数第N个节点
题目描述：

&emsp;&emsp;给定一个链表，删除链表的倒数第 n 个节点，并且返回链表的头结点。

    示例：
    给定一个链表: 1->2->3->4->5, 和 n = 2.
    当删除了倒数第二个节点后，链表变为 1->2->3->5.
    说明：
    给定的 n 保证是有效的。
    进阶：
    你能尝试使用一趟扫描实现吗？
[解题源码](RemoveNthFromEnd.java)
### 20. 有效的括号
题目描述：

&emsp;&emsp;给定一个只包括 '('，')'，'{'，'}'，'['，']' 的字符串，判断字符串是否有效。

     有效字符串需满足：

     左括号必须用相同类型的右括号闭合。
     左括号必须以正确的顺序闭合。
     注意空字符串可被认为是有效字符串
[解题源码](BracketIsValid.java)
### 21. 合并两个有序链表
题目描述：

&emsp;&emsp;将两个有序链表合并为一个新的有序链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。 

    示例：
    输入：1->2->4, 1->3->4
    输出：1->1->2->3->4->4
[解题源码](MergeTwoLists.java)
### 22. 括号生成
题目描述：

&emsp;&emsp;给出 n 代表生成括号的对数，请你写出一个函数，使其能够生成所有可能的并且有效的括号组合。
	例如，给出 n = 3，生成结果为：

	[
	  "((()))",
	  "(()())",
	  "(())()",
	  "()(())",
	  "()()()"
	]
[解题源码](BracketCreate.java)
### 24. 两两交换链表中的节点
题目描述：

&emsp;&emsp;给定一个链表，两两交换其中相邻的节点，并返回交换后的链表。

            你不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。

             

            示例:

            给定 1->2->3->4, 你应该返回 2->1->4->3.
[解题源码](SwapListNodePairs.java)
### 25. K 个一组翻转链表
题目描述：

&emsp;&emsp;给你一个链表，每 k 个节点一组进行翻转，请你返回翻转后的链表。

            k 是一个正整数，它的值小于或等于链表的长度。

            如果节点总数不是 k 的整数倍，那么请将最后剩余的节点保持原有顺序。

            示例 :

            给定这个链表：1->2->3->4->5

            当 k = 2 时，应当返回: 2->1->4->3->5

            当 k = 3 时，应当返回: 3->2->1->4->5

            说明 :

            你的算法只能使用常数的额外空间。
            你不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。
            在真实的面试中遇到过这道题？
[解题源码](ReverseKGroupListNode.java)
### 26. 删除排序数组中的重复项
题目描述：

&emsp;&emsp;给定一个排序数组，你需要在原地删除重复出现的元素，使得每个元素只出现一次，返回移除后数组的新长度。

            不要使用额外的数组空间，你必须在原地修改输入数组并在使用 O(1) 额外空间的条件下完成。

            示例 1:

            给定数组 nums = [1,1,2],

            函数应该返回新的长度 2, 并且原数组 nums 的前两个元素被修改为 1, 2。

            你不需要考虑数组中超出新长度后面的元素。
            示例 2:

            给定 nums = [0,0,1,1,1,2,2,3,3,4],

            函数应该返回新的长度 5, 并且原数组 nums 的前五个元素被修改为 0, 1, 2, 3, 4。

            你不需要考虑数组中超出新长度后面的元素。
            说明:

            为什么返回数值是整数，但输出的答案是数组呢?

            请注意，输入数组是以“引用”方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。

            你可以想象内部操作如下:

            // nums 是以“引用”方式传递的。也就是说，不对实参做任何拷贝
            int len = removeDuplicates(nums);

            // 在函数里修改输入数组对于调用者是可见的。
            // 根据你的函数返回的长度, 它会打印出数组中该长度范围内的所有元素。
            for (int i = 0; i < len; i++) {
                print(nums[i]);
            }
[解题源码](RemoveDuplicates.java)
### 27. 移除元素
题目描述：

&emsp;&emsp;给定一个数组 nums 和一个值 val，你需要原地移除所有数值等于 val 的元素，返回移除后数组的新长度。

    不要使用额外的数组空间，你必须在原地修改输入数组并在使用 O(1) 额外空间的条件下完成。
    元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。

[解题源码](RemoveElement.java)
### 28. 实现 strStr()
题目描述：

&emsp;&emsp;实现 strStr() 函数。
     给定一个 haystack 字符串和一个 needle 字符串，在 haystack 字符串中找出 needle 字符串出现的第一个位置 (从0开始)。如果不存在，则返回  -1

    说明:
    当 needle 是空字符串时，我们应当返回什么值呢？这是一个在面试中很好的问题。
    对于本题而言，当 needle 是空字符串时我们应当返回 0 。这与C语言的 strstr() 以及 Java的 indexOf() 定义相符。
[解题源码](ImplementStrStr.java)
### 29. 两数相除
题目描述：

&emsp;&emsp;给定两个整数，被除数 dividend 和除数 divisor。将两数相除，要求不使用乘法、除法和 mod 运算符。

	返回被除数 dividend 除以除数 divisor 得到的商。
	示例 1:
	输入: dividend = 10, divisor = 3
	输出: 3
	示例 2:
	输入: dividend = 7, divisor = -3
	输出: -2
	说明:
	被除数和除数均为 32 位有符号整数。
	除数不为 0。
	假设我们的环境只能存储 32 位有符号整数，其数值范围是 [−231,  231 − 1]。本题中，如果除法结果溢出，则返回 231 − 1。
[解题源码](DivideTwoInt.java)
### 30. 串联所有单词的子串
题目描述：

&emsp;&emsp;给定一个字符串 s 和一些长度相同的单词 words。找出 s 中恰好可以由 words 中所有单词串联形成的子串的起始位置。
注意子串要与 words 中的单词完全匹配，中间不能有其他字符，但不需要考虑 words 中单词串联的顺序。
[解题源码](FindWordSubstringInString.java)
### 31. 下一个排列
题目描述：

&emsp;&emsp;实现获取下一个排列的函数，算法需要将给定数字序列重新排列成字典序中下一个更大的排列。

	如果不存在下一个更大的排列，则将数字重新排列成最小的排列（即升序排列）。

	必须原地修改，只允许使用额外常数空间。

	以下是一些例子，输入位于左侧列，其相应输出位于右侧列。
	1,2,3 → 1,3,2
	3,2,1 → 1,2,3
	1,1,5 → 1,5,1
[解题源码](·.java)
### 32. 最长有效括号
题目描述：

&emsp;&emsp;给定一个只包含 '(' 和 ')' 的字符串，找出最长的包含有效括号的子串的长度。


[解题源码](LongestValidParentheses.java)
### 33. 搜索旋转排序数组
题目描述：

&emsp;&emsp;假设按照升序排序的数组在预先未知的某个点上进行了旋转。
( 例如，数组 [0,1,2,4,5,6,7] 可能变为 [4,5,6,7,0,1,2] )。
搜索一个给定的目标值，如果数组中存在这个目标值，则返回它的索引，否则返回 -1 。
你可以假设数组中不存在重复的元素。
你的算法时间复杂度必须是 O(log n) 级别。
```
示例 1:

输入: nums = [4,5,6,7,0,1,2], target = 0
输出: 4
示例 2:

输入: nums = [4,5,6,7,0,1,2], target = 3
输出: -1
```
[解题源码](SearchRotateSortArray.java)
### 34. 在排序数组中查找元素的第一个和最后一个位置
题目描述：

&emsp;&emsp;给定一个按照升序排列的整数数组 nums，和一个目标值 target。找出给定目标值在数组中的开始位置和结束位置。
你的算法时间复杂度必须是 O(log n) 级别。
如果数组中不存在目标值，返回 [-1, -1]。

```
示例 1:
输入: nums = [5,7,7,8,8,10], target = 8
输出: [3,4]
示例 2:

输入: nums = [5,7,7,8,8,10], target = 6
输出: [-1,-1]
```
[解题源码](SearchRangeFirstAndEnd.java)
### 35. 搜索插入位置
题目描述：

&emsp;&emsp;给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。
你可以假设数组中无重复元素。

```
示例 1:

输入: [1,3,5,6], 5
输出: 2
示例 2:

输入: [1,3,5,6], 2
输出: 1
示例 3:

输入: [1,3,5,6], 7
输出: 4
示例 4:

输入: [1,3,5,6], 0
输出: 0
```
[解题源码](SearchLocationToInsert.java)
### 36. 有效的数独
题目描述：

&emsp;&emsp;判断一个 9x9 的数独是否有效。只需要根据以下规则，验证已经填入的数字是否有效即可。
1. 数字 1-9 在每一行只能出现一次。
2. 数字 1-9 在每一列只能出现一次。
3. 数字 1-9 在每一个以粗实线分隔的 3x3 宫内只能出现一次。

[解题源码](IsValidSudoku.java)
### 37. 解数独
题目描述：

&emsp;&emsp;编写一个程序，通过已填充的空格来解决数独问题。
1. 数字 1-9 在每一行只能出现一次。
2. 数字 1-9 在每一列只能出现一次。
3. 数字 1-9 在每一个以粗实线分隔的 3x3 宫内只能出现一次。

[解题源码](SolveSudoku.java)
### 38. 报数
题目描述：

&emsp;&emsp;报数序列是一个整数序列，按照其中的整数的顺序进行报数，得到下一个数。其前五项如下：
```
1.     1
2.     11
3.     21
4.     1211
5.     111221

1 被读作  "one 1"  ("一个一") , 即 11。
11 被读作 "two 1s" ("两个一"）, 即 21。
21 被读作 "one 2",  "one 1" （"一个二" ,  "一个一") , 即 1211。
给定一个正整数 n（1 ≤ n ≤ 30），输出报数序列的第 n 项。
注意：整数顺序将表示为一个字符串。
示例 1:
    输入: 1
    输出: "1"
    示例 2:

    输入: 4
    输出: "1211"
```
[解题源码](CountAndSay.java)
### 39. 组合总和
题目描述：

&emsp;&emsp;给定一个无重复元素的数组 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合。
            candidates 中的数字可以无限制重复被选取。
            说明：
            所有数字（包括 target）都是正整数。
            解集不能包含重复的组合。
```
示例 1:

输入: candidates = [2,3,6,7], target = 7,
所求解集为:
[
  [7],
  [2,2,3]
]
示例 2:

输入: candidates = [2,3,5], target = 8,
所求解集为:
[
  [2,2,2,2],
  [2,3,3],
  [3,5]
]
```
[解题源码](CombinationSum.java)
### 40. 组合总和 II
题目描述：

&emsp;&emsp;给定一个数组 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合。
            candidates 中的每个数字在每个组合中只能使用一次。
            说明：
            所有数字（包括 target）都是正整数。
            解集不能包含重复的组合。
```
示例 1:

输入: candidates = [10,1,2,7,6,1,5], target = 8,
所求解集为:
[
  [1, 7],
  [1, 2, 5],
  [2, 6],
  [1, 1, 6]
]
输入: candidates = [2,5,2,1,2], target = 5,
所求解集为:
[
  [1,2,2],
  [5]
]
```
[解题源码](CombinationSum2.java)
### 41. 缺失的第一个正数
题目描述：

&emsp;&emsp;给定一个未排序的整数数组，找出其中没有出现的最小的正整数。
```
示例 1:

输入: [1,2,0]
输出: 3
示例 2:

输入: [3,4,-1,1]
输出: 2
示例 3:

输入: [7,8,9,11,12]
输出: 1
```
你的算法的时间复杂度应为O(n)，并且只能使用常数级别的空间。

[解题源码](FirstMissingPositive.java)
### 42. 接雨水
题目描述：

&emsp;&emsp;给定 n 个非负整数表示每个宽度为 1 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水
![接雨水](../../../../../../image/接雨水.png)
```
示例:

输入: [0,1,0,2,1,0,1,3,2,1,2,1]
输出: 6
```

[解题源码](TrapRainWater.java)
### 43. 字符串相乘
题目描述：

&emsp;&emsp;给定两个以字符串形式表示的非负整数 num1 和 num2，返回 num1 和 num2 的乘积，它们的乘积也表示为字符串形式。
```
示例 1:

输入: num1 = "2", num2 = "3"
输出: "6"
示例 2:

输入: num1 = "123", num2 = "456"
输出: "56088"
```
说明：

- num1 和 num2 的长度小于110。
- num1 和 num2 只包含数字 0-9。
- num1 和 num2 均不以零开头，除非是数字 0 本身。
- 不能使用任何标准库的大数类型（比如 BigInteger）或直接将输入转换为整数来处理。

[解题源码](MultiplyString.java)
### 46. Permutations
题目描述：

&emsp;&emsp;给定一个没有重复数字的序列，返回其所有可能的全排列。
 示例:

 输入: [1,2,3]
输出:
[
  [1,2,3],
  [1,3,2],
  [2,1,3],
  [2,3,1],
  [3,1,2],
  [3,2,1]
]
 Related Topics 回溯算法

[解题源码](_46_Permutations.java)
### 48. Rotate Image
题目描述：

&emsp;&emsp;给定一个 n × n 的二维矩阵表示一个图像。
 将图像顺时针旋转 90 度。

 说明：

 你必须在原地旋转图像，这意味着你需要直接修改输入的二维矩阵。请不要使用另一个矩阵来旋转图像。

 示例 1:

 给定 matrix =
[
  [1,2,3],
  [4,5,6],
  [7,8,9]
],

原地旋转输入矩阵，使其变为:
[
  [7,4,1],
  [8,5,2],
  [9,6,3]
]


 示例 2:

 给定 matrix =
[
  [ 5, 1, 9,11],
  [ 2, 4, 8,10],
  [13, 3, 6, 7],
  [15,14,12,16]
],

原地旋转输入矩阵，使其变为:
[
  [15,13, 2, 5],
  [14, 3, 4, 1],
  [12, 6, 8, 9],
  [16, 7,10,11]
]

 Related Topics 数组

[解题源码](_48_RotateImage.java)
### 49. 字母异位词分组
题目描述：

&emsp;&emsp;给定一个字符串数组，将字母异位词组合在一起。字母异位词指字母相同，但排列不同的字符串。

 示例:

 输入: ["eat", "tea", "tan", "ate", "nat", "bat"],
输出:
[
  ["ate","eat","tea"],
  ["nat","tan"],
  ["bat"]
]

 说明：


 所有输入均为小写字母。
 不考虑答案输出的顺序。

 Related Topics 哈希表 字符串
[解题源码](_49_GroupAnagrams.java)
### 50. Pow(x, n)
题目描述：

&emsp;&emsp;实现 pow(x, n) ，即计算 x 的 n 次幂函数。

示例 1:

输入: 2.00000, 10
输出: 1024.00000


示例 2:

输入: 2.10000, 3
输出: 9.26100


示例 3:

输入: 2.00000, -2
输出: 0.25000
解释: 2-2 = 1/22 = 1/4 = 0.25

说明:


-100.0 < x < 100.0
n 是 32 位有符号整数，其数值范围是 [−231, 231 − 1] 。

Related Topics 数学 二分查找
[解题源码](_50_PowxN.java)
### 51. N-Queens
题目描述：

&emsp;&emsp;实现 pow(x, n) ，即计算 x 的 n 次幂函数。

示例 1:

输入: 2.00000, 10
输出: 1024.00000


示例 2:

输入: 2.10000, 3
输出: 9.26100


示例 3:

输入: 2.00000, -2
输出: 0.25000
解释: 2-2 = 1/22 = 1/4 = 0.25

说明:


-100.0 < x < 100.0
n 是 32 位有符号整数，其数值范围是 [−231, 231 − 1] 。

Related Topics 数学 二分查找
[解题源码](_50_PowxN.java)
### 53. Maximum Subarray
题目描述：

&emsp;&emsp;给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。

示例:

输入: [-2,1,-3,4,-1,2,1,-5,4],
输出: 6
解释: 连续子数组 [4,-1,2,1] 的和最大，为 6。


进阶:

如果你已经实现复杂度为 O(n) 的解法，尝试使用更为精妙的分治法求解。
Related Topics 数组 分治算法 动态规划
[解题源码](_53_MaximumSubarray.java)
### 54. Spiral Matrix
题目描述：

&emsp;&emsp;给定一个包含 m x n 个元素的矩阵（m 行, n 列），请按照顺时针螺旋顺序，返回矩阵中的所有元素。

示例 1:

输入:
[
 [ 1, 2, 3 ],
 [ 4, 5, 6 ],
 [ 7, 8, 9 ]
]
输出: [1,2,3,6,9,8,7,4,5]

示例 2:
输入:
[
  [1, 2, 3, 4],
  [5, 6, 7, 8],
  [9,10,11,12]
]
输出: [1,2,3,4,8,12,11,10,9,5,6,7]

Related Topics 数组
[解题源码](_54_SpiralMatrix.java)
### 55. JumpGame
题目描述：

&emsp;&emsp;给定一个非负整数数组，你最初位于数组的第一个位置。

数组中的每个元素代表你在该位置可以跳跃的最大长度。
判断你是否能够到达最后一个位置。

示例 1:

输入: [2,3,1,1,4]
输出: true
解释: 我们可以先跳 1 步，从位置 0 到达 位置 1, 然后再从位置 1 跳 3 步到达最后一个位置。

示例 2:
输入: [3,2,1,0,4]
输出: false
解释: 无论怎样，你总会到达索引为 3 的位置。但该位置的最大跳跃长度是 0 ， 所以你永远不可能到达最后一个位置。
Related Topics 贪心算法 数组
[解题源码](_56_MergeIntervals.java)
### 56. Merge Intervals
题目描述：

&emsp;&emsp;给出一个区间的集合，请合并所有重叠的区间。

示例 1:

输入: [[1,3],[2,6],[8,10],[15,18]]
输出: [[1,6],[8,10],[15,18]]
解释: 区间 [1,3] 和 [2,6] 重叠, 将它们合并为 [1,6].

示例 2:
输入: [[1,4],[4,5]]
输出: [[1,5]]
解释: 区间 [1,4] 和 [4,5] 可被视为重叠区间。
Related Topics 排序 数组
[解题源码](_56_MergeIntervals.java)
### 57. Insert Interval
题目描述：

&emsp;&emsp;给出一个无重叠的 ，按照区间起始端点排序的区间列表。


 在列表中插入一个新的区间，你需要确保列表中的区间仍然有序且不重叠（如果有必要的话，可以合并区间）。

 示例 1:

 输入: intervals = [[1,3],[6,9]], newInterval = [2,5]
输出: [[1,5],[6,9]]


 示例 2:

 输入: intervals = [[1,2],[3,5],[6,7],[8,10],[12,16]], newInterval = [4,8]
输出: [[1,2],[3,10],[12,16]]
解释: 这是因为新的区间 [4,8] 与 [3,5],[6,7],[8,10] 重叠。

 Related Topics 排序 数组
[解题源码](_57_InsertInterval.java)
### 58. Length of Last Word
题目描述：

&emsp;&emsp;给定一个仅包含大小写字母和空格 ' ' 的字符串，返回其最后一个单词的长度。


如果不存在最后一个单词，请返回 0 。

说明：一个单词是指由字母组成，但不包含任何空格的字符串。

示例:

输入: "Hello World"
输出: 5

Related Topics 字符串
[解题源码](_58_LengthOfLastWord.java)
### 59. Spiral Matrix II
题目描述：

&emsp;&emsp;给定一个正整数 n，生成一个包含 1 到 n2 所有元素，且元素按顺时针顺序螺旋排列的正方形矩阵。

示例:

输入: 3
输出:
[
[ 1, 2, 3 ],
[ 8, 9, 4 ],
[ 7, 6, 5 ]
]
Related Topics 数组
[解题源码](_59_SpiralMatrixIi.java)
###  60. Permutation Sequence
题目描述：

&emsp;&emsp;给出集合 [1,2,3,…,n]，其所有元素共有 n! 种排列。

按大小顺序列出所有排列情况，并一一标记，当 n = 3 时, 所有排列如下：
"123"
"132"
"213"
"231"
"312"
"321"

给定 n 和 k，返回第 k 个排列。

说明：


给定 n 的范围是 [1, 9]。
给定 k 的范围是[1, n!]。

示例 1:

输入: n = 3, k = 3
输出: "213"


示例 2:

输入: n = 4, k = 9
输出: "2314"

Related Topics 数学 回溯算法
[解题源码](_60_PermutationSequence.java)
###  61. Rotate List
题目描述：

&emsp;&emsp;给定一个链表，旋转链表，将链表每个节点向右移动 k 个位置，其中 k 是非负数。

示例 1:

输入: 1->2->3->4->5->NULL, k = 2
输出: 4->5->1->2->3->NULL
解释:
向右旋转 1 步: 5->1->2->3->4->NULL
向右旋转 2 步: 4->5->1->2->3->NULL


示例 2:

输入: 0->1->2->NULL, k = 4
输出: 2->0->1->NULL
解释:
向右旋转 1 步: 2->0->1->NULL
向右旋转 2 步: 1->2->0->NULL
向右旋转 3 步: 0->1->2->NULL
向右旋转 4 步: 2->0->1->NULL
Related Topics 链表 双指针
[解题源码](_61_RotateList.java)
###  62. Unique Paths
题目描述：

&emsp;&emsp;一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为“Start” ）。
            机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为“Finish”）。
            问总共有多少条不同的路径？

例如，上图是一个7 x 3 的网格。有多少可能的路径？

说明：m 和 n 的值均不超过 100。

示例 1:

输入: m = 3, n = 2
输出: 3
解释:
从左上角开始，总共有 3 条路径可以到达右下角。
1. 向右 -> 向右 -> 向下
2. 向右 -> 向下 -> 向右
3. 向下 -> 向右 -> 向右


示例 2:

输入: m = 7, n = 3
输出: 28
Related Topics 数组 动态规划
[解题源码](_62_UniquePaths.java)
###  63. Unique Paths II
题目描述：

&emsp;&emsp;一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为“Start” ）。
            机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为“Finish”）。
            现在考虑网格中有障碍物。那么从左上角到右下角将会有多少条不同的路径？

网格中的障碍物和空位置分别用 1 和 0 来表示。

说明：m 和 n 的值均不超过 100。

示例 1:

输入:
[
  [0,0,0],
  [0,1,0],
  [0,0,0]
]
输出: 2
解释:
3x3 网格的正中间有一个障碍物。
从左上角到右下角一共有 2 条不同的路径：
1. 向右 -> 向右 -> 向下 -> 向下
2. 向下 -> 向下 -> 向右 -> 向右

Related Topics 数组 动态规划
[解题源码](_63_UniquePathsIi.java)
###  64. Minimum Path Sum
题目描述：

&emsp;&emsp;给定一个包含非负整数的 m x n 网格，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。


说明：每次只能向下或者向右移动一步。

示例:

输入:
[
  [1,3,1],
[1,5,1],
[4,2,1]
]
输出: 7
解释: 因为路径 1→3→1→1→1 的总和最小。

Related Topics 数组 动态规划
[解题源码](_64_MinimumPathSum.java)
###   65. Valid Number
题目描述：

&emsp;&emsp;验证给定的字符串是否可以解释为十进制数字。

例如:

"0" => true
" 0.1 " => true
"abc" => false
"1 a" => false
"2e10" => true
" -90e3 " => true
" 1e" => false
"e3" => false
" 6e-1" => true
" 99e2.5 " => false
"53.5e93" => true
" --6 " => false
"-+3" => false
"95a54e53" => false

说明: 我们有意将问题陈述地比较模糊。在实现代码之前，你应当事先思考所有可能的情况。这里给出一份可能存在于有效十进制数字中的字符列表：


数字 0-9
指数 - "e"
正/负号 - "+"/"-"
小数点 - "."


当然，在输入中，这些字符的上下文也很重要。

更新于 2015-02-10:
C++函数的形式已经更新了。如果你仍然看见你的函数接收 const char * 类型的参数，请点击重载按钮重置你的代码。
Related Topics 数学 字符串
[解题源码](_65_ValidNumber.java)
###   66. Plus One
题目描述：

&emsp;&emsp;给定一个由整数组成的非空数组所表示的非负整数，在该数的基础上加一。

最高位数字存放在数组的首位， 数组中每个元素只存储单个数字。

你可以假设除了整数 0 之外，这个整数不会以零开头。

示例 1:

输入: [1,2,3]
输出: [1,2,4]
解释: 输入数组表示数字 123。


示例 2:

输入: [4,3,2,1]
输出: [4,3,2,2]
解释: 输入数组表示数字 4321。

Related Topics 数组
[解题源码](_66_PlusOne.java)
###   67. Add Binary
题目描述：

&emsp;&emsp;给定两个二进制字符串，返回他们的和（用二进制表示）


输入为非空字符串且只包含数字 1 和 0。

示例 1:

输入: a = "11", b = "1"
输出: "100"

示例 2:

输入: a = "1010", b = "1011"
输出: "10101"
Related Topics 数学 字符串
[解题源码](_67_AddBinary.java)
###   68. Text Justification
题目描述：

&emsp;&emsp;给定一个单词数组和一个长度 maxWidth，重新排版单词，使其成为每行恰好有 maxWidth 个字符，且左右两端对齐的文本。
            你应该使用“贪心算法”来放置给定的单词；也就是说，尽可能多地往每行中放置单词。必要时可用空格 ' ' 填充，使得每行恰好有 maxWidth 个字符。
            要求尽可能均匀分配单词间的空格数量。如果某一行单词间的空格不能均匀分配，则左侧放置的空格数要多于右侧的空格数。
            文本的最后一行应为左对齐，且单词之间不插入额外的空格。


说明:


单词是指由非空格字符组成的字符序列。
每个单词的长度大于 0，小于等于 maxWidth。
输入单词数组 words 至少包含一个单词。


示例:

输入:
words = ["This", "is", "an", "example", "of", "text", "justification."]
maxWidth = 16
输出:
[
   "This    is    an",
   "example  of text",
   "justification.  "
]


示例 2:

输入:
words = ["What","must","be","acknowledgment","shall","be"]
maxWidth = 16
输出:
[
  "What   must   be",
  "acknowledgment  ",
  "shall be        "
]
解释: 注意最后一行的格式应为 "shall be    " 而不是 "shall     be",
     因为最后一行应为左对齐，而不是左右两端对齐。
 第二行同样为左对齐，这是因为这行只包含一个单词。


示例 3:

输入:
words = ["Science","is","what","we","understand","well","enough","to","explain",
         "to","a","computer.","Art","is","everything","else","we","do"]
maxWidth = 20
输出:
[
  "Science  is  what we",
"understand      well",
  "enough to explain to",
  "a  computer.  Art is",
  "everything  else  we",
  "do                  "
]
Related Topics 字符串
[解题源码](_68_TextJustification.java)
###   69. Sqrt(x)
题目描述：

&emsp;&emsp;实现 int sqrt(int x) 函数。

计算并返回 x 的平方根，其中 x 是非负整数。

由于返回类型是整数，结果只保留整数的部分，小数部分将被舍去。

示例 1:

输入: 4
输出: 2


示例 2:

输入: 8
输出: 2
说明: 8 的平方根是 2.82842...,
     由于返回类型是整数，小数部分将被舍去。

Related Topics 数学 二分查找
[解题源码](_69_Sqrtx.java)
###    70. Climbing Stairs
题目描述：

&emsp;&emsp;假设你正在爬楼梯。需要 n 阶你才能到达楼顶。
            每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？

注意：给定 n 是一个正整数。

示例 1：

输入： 2
输出： 2
解释： 有两种方法可以爬到楼顶。
1.  1 阶 + 1 阶
2.  2 阶

示例 2：

输入： 3
输出： 3
解释： 有三种方法可以爬到楼顶。
1.  1 阶 + 1 阶 + 1 阶
2.  1 阶 + 2 阶
3.  2 阶 + 1 阶

Related Topics 动态规划
[解题源码](_70_ClimbingStairs.java)
###    71. Simplify Path
题目描述：

&emsp;&emsp;以 Unix 风格给出一个文件的绝对路径，你需要简化它。或者换句话说，将其转换为规范路径。
            在 Unix 风格的文件系统中，一个点（.）表示当前目录本身；此外，两个点 （..） 表示将目录切换到上一级（指向父目录）；两者都可以是复杂相对路径的组成部分。更多信息请参阅：Linux / Unix中的绝对路径 vs 相对路径
            请注意，返回的规范路径必须始终以斜杠 / 开头，并且两个目录名之间必须只有一个斜杠 /。最后一个目录名（如果存在）不能以 / 结尾。此外，规范路径必须是表示绝对路径的最短字符串。

示例 1：

输入："/home/"
输出："/home"
解释：注意，最后一个目录名后面没有斜杠。


示例 2：

输入："/../"
输出："/"
解释：从根目录向上一级是不可行的，因为根是你可以到达的最高级。


示例 3：

输入："/home//foo/"
输出："/home/foo"
解释：在规范路径中，多个连续斜杠需要用一个斜杠替换。


示例 4：

输入："/a/./b/../../c/"
输出："/c"


示例 5：

输入："/a/../../b/../c//.//"
输出："/c"


示例 6：

输入："/a//b////c/d//././/.."
输出："/a/b/c"
Related Topics 栈 字符串
[解题源码](_71_SimplifyPath.java)
###    73. Set Matrix Zeroes
题目描述：

&emsp;&emsp;给定一个 m x n 的矩阵，如果一个元素为 0，则将其所在行和列的所有元素都设为 0。请使用原地算法。

示例 1:

输入:
[
  [1,1,1],
  [1,0,1],
  [1,1,1]
]
输出:
[
  [1,0,1],
  [0,0,0],
  [1,0,1]
]


示例 2:

输入:
[
  [0,1,2,0],
  [3,4,5,2],
  [1,3,1,5]
]
输出:
[
  [0,0,0,0],
  [0,4,5,0],
  [0,3,1,0]
]

进阶:


一个直接的解决方案是使用 O(mn) 的额外空间，但这并不是一个好的解决方案。
一个简单的改进方案是使用 O(m + n) 的额外空间，但这仍然不是最好的解决方案。
你能想出一个常数空间的解决方案吗？

Related Topics 数组
[解题源码](_73_SetMatrixZeroes.java)
###   74. Search a 2D Matrix
题目描述：

&emsp;&emsp;编写一个高效的算法来判断 m x n 矩阵中，是否存在一个目标值。该矩阵具有如下特性：
            每行中的整数从左到右按升序排列。
            每行的第一个整数大于前一行的最后一个整数。



示例 1:

输入:
matrix = [
[1,   3,  5,  7],
[10, 11, 16, 20],
[23, 30, 34, 50]
]
target = 3
输出: true


示例 2:

输入:
matrix = [
[1,   3,  5,  7],
[10, 11, 16, 20],
[23, 30, 34, 50]
]
target = 13
输出: false
Related Topics 数组 二分查找
[解题源码](_74_SearchA2dMatrix.java)
###   75. Sort Colors
题目描述：

&emsp;&emsp;给定一个包含红色、白色和蓝色，一共 n 个元素的数组，原地对它们进行排序，使得相同颜色的元素相邻，并按照红色、白色、蓝色顺序排列。
            此题中，我们使用整数 0、 1 和 2 分别表示红色、白色和蓝色。

注意:
不能使用代码库中的排序函数来解决这道题。

示例:

输入: [2,0,2,1,1,0]
输出: [0,0,1,1,2,2]

进阶：


一个直观的解决方案是使用计数排序的两趟扫描算法。
首先，迭代计算出0、1 和 2 元素的个数，然后按照0、1、2的排序，重写当前数组。
你能想出一个仅使用常数空间的一趟扫描算法吗？

Related Topics 排序 数组 双指针
[解题源码](_75_SortColors.java)
###    77. Combinations
题目描述：

&emsp;&emsp;给定两个整数 n 和 k，返回 1 ... n 中所有可能的 k 个数的组合。

示例:

输入: n = 4, k = 2
输出:
[
[2,4],
[3,4],
[2,3],
[1,2],
[1,3],
[1,4],
]
Related Topics 回溯算法
[解题源码](_77_Combinations.java)
###    78. Subsets
题目描述：

&emsp;&emsp;给定一组不含重复元素的整数数组 nums，返回该数组所有可能的子集（幂集）。
            说明：解集不能包含重复的子集。

示例:

输入: nums = [1,2,3]
输出:
[
[3],
  [1],
  [2],
  [1,2,3],
  [1,3],
  [2,3],
  [1,2],
  []
]
Related Topics 位运算 数组 回溯算法
[解题源码](_78_Subsets.java)
### 79. Word Search
题目描述：

&emsp;&emsp;给定一个二维网格和一个单词，找出该单词是否存在于网格中。
            单词必须按照字母顺序，通过相邻的单元格内的字母构成，其中“相邻”单元格是那些水平相邻或垂直相邻的单元格。同一个单元格内的字母不允许被重复使用。


示例:

board =
[
['A','B','C','E'],
['S','F','C','S'],
['A','D','E','E']
]

给定 word = "ABCCED", 返回 true.
给定 word = "SEE", 返回 true.
给定 word = "ABCB", 返回 false.
Related Topics 数组 回溯算法
[解题源码](_79_WordSearch.java)
### 80. Remove Duplicates from Sorted Array II
题目描述：

&emsp;&emsp;给定一个排序数组，你需要在原地删除重复出现的元素，使得每个元素最多出现两次，返回移除后数组的新长度。
            不要使用额外的数组空间，你必须在原地修改输入数组并在使用 O(1) 额外空间的条件下完成。

示例 1:

给定 nums = [1,1,1,2,2,3],

函数应返回新长度 length = 5, 并且原数组的前五个元素被修改为 1, 1, 2, 2, 3 。

你不需要考虑数组中超出新长度后面的元素。

示例 2:

给定 nums = [0,0,1,1,1,1,2,3,3],

函数应返回新长度 length = 7, 并且原数组的前五个元素被修改为 0, 0, 1, 1, 2, 3, 3 。

你不需要考虑数组中超出新长度后面的元素。


说明:

为什么返回数值是整数，但输出的答案是数组呢?

请注意，输入数组是以“引用”方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。

你可以想象内部操作如下:

// nums 是以“引用”方式传递的。也就是说，不对实参做任何拷贝
int len = removeDuplicates(nums);

// 在函数里修改输入数组对于调用者是可见的。
// 根据你的函数返回的长度, 它会打印出数组中该长度范围内的所有元素。
for (int i = 0; i < len; i++) {
    print(nums[i]);
}
Related Topics 数组 双指针
[解题源码](_80_RemoveDuplicatesFromSortedArrayIi.java)
### 81. Search in Rotated Sorted Array II
题目描述：

&emsp;&emsp;假设按照升序排序的数组在预先未知的某个点上进行了旋转。

( 例如，数组 [0,0,1,2,2,5,6] 可能变为 [2,5,6,0,0,1,2] )。

编写一个函数来判断给定的目标值是否存在于数组中。若存在返回 true，否则返回 false。

示例 1:

输入: nums = [2,5,6,0,0,1,2], target = 0
输出: true


示例 2:

输入: nums = [2,5,6,0,0,1,2], target = 3
输出: false

进阶:


这是 搜索旋转排序数组 的延伸题目，本题中的 nums 可能包含重复元素。
这会影响到程序的时间复杂度吗？会有怎样的影响，为什么？
Related Topics 数组 二分查找
[解题源码](_81_SearchInRotatedSortedArrayIi.java)
### 82. Remove Duplicates from Sorted List II
题目描述：

&emsp;&emsp;给定一个排序链表，删除所有含有重复数字的节点，只保留原始链表中 没有重复出现 的数字。


示例 1:

输入: 1->2->3->3->4->4->5
输出: 1->2->5


示例 2:

输入: 1->1->1->2->3
输出: 2->3
Related Topics 链表
[解题源码](_82_RemoveDuplicatesFromSortedListIi.java)
### 83. Remove Duplicates from Sorted List
题目描述：

&emsp;&emsp;给定一个排序链表，删除所有重复的元素，使得每个元素只出现一次。


示例 1:

输入: 1->1->2
输出: 1->2


示例 2:

输入: 1->1->2->3->3
输出: 1->2->3
Related Topics 链表
[解题源码](_83_RemoveDuplicatesFromSortedList.java)
### 86. Partition List
题目描述：

&emsp;&emsp;给定一个链表和一个特定值 x，对链表进行分隔，使得所有小于 x 的节点都在大于或等于 x 的节点之前。

你应当保留两个分区中每个节点的初始相对位置。

示例:

输入: head = 1->4->3->2->5->2, x = 3
输出: 1->2->2->4->3->5

Related Topics 链表 双指针
[解题源码](_86_PartitionList.java)
### 88. Merge Sorted Array
题目描述：

&emsp;&emsp;给定两个有序整数数组 nums1 和 nums2，将 nums2 合并到 nums1 中，使得 num1 成为一个有序数组。

说明:

初始化 nums1 和 nums2 的元素数量分别为 m 和 n。
你可以假设 nums1 有足够的空间（空间大小大于或等于 m + n）来保存 nums2 中的元素。


示例:

输入:
nums1 = [1,2,3,0,0,0], m = 3
nums2 = [2,5,6],       n = 3

输出: [1,2,2,3,5,6]
Related Topics 数组 双指针
[解题源码](_88_MergeSortedArray.java)
### 89. Gray Code
题目描述：

&emsp;&emsp;格雷编码是一个二进制数字系统，在该系统中，两个连续的数值仅有一个位数的差异。
给定一个代表编码总位数的非负整数 n，打印其格雷编码序列。格雷编码序列必须以 0 开头。

示例 1:

输入: 2
输出: [0,1,3,2]
解释:
00 - 0
01 - 1
11 - 3
10 - 2

对于给定的 n，其格雷编码序列并不唯一。
例如，[0,2,3,1] 也是一个有效的格雷编码序列。

00 - 0
10 - 2
11 - 3
01 - 1

示例 2:

输入: 0
输出: [0]
解释: 我们定义格雷编码序列必须以 0 开头。
     给定编码总位数为 n 的格雷编码序列，其长度为 2n。当 n = 0 时，长度为 20 = 1。
     因此，当 n = 0 时，其格雷编码序列为 [0]。

Related Topics 回溯算法

[解题源码](_89_GrayCode.java)
###  90. Subsets II
题目描述：

&emsp;&emsp;给定一个可能包含重复元素的整数数组 nums，返回该数组所有可能的子集（幂集）。

说明：解集不能包含重复的子集。

示例:

输入: [1,2,2]
输出:
[
[2],
[1],
[1,2,2],
[2,2],
[1,2],
[]
]
Related Topics 数组 回溯算法

[解题源码](_90_SubsetsIi.java)
### 91. Decode Ways
题目描述：

&emsp;&emsp;一条包含字母 A-Z 的消息通过以下方式进行了编码：

'A' -> 1
'B' -> 2
...
'Z' -> 26


给定一个只包含数字的非空字符串，请计算解码方法的总数。

示例 1:

输入: "12"
输出: 2
解释: 它可以解码为 "AB"（1 2）或者 "L"（12）。


示例 2:

输入: "226"
输出: 3
解释: 它可以解码为 "BZ" (2 26), "VF" (22 6), 或者 "BBF" (2 2 6) 。

Related Topics 字符串 动态规划
[解题源码](_91_DecodeWays.java)
### 92. Reverse Linked List II
题目描述：

&emsp;&emsp;反转从位置 m 到 n 的链表。请使用一趟扫描完成反转。

 说明:
1 ≤ m ≤ n ≤ 链表长度。

 示例:

 输入: 1->2->3->4->5->NULL, m = 2, n = 4
输出: 1->4->3->2->5->NULL
 Related Topics 链表
[解题源码](_92_ReverseLinkedListIi.java)
### 93. Restore IP Addresses
题目描述：

&emsp;&emsp;给定一个只包含数字的字符串，复原它并返回所有可能的 IP 地址格式。

示例:

输入: "25525511135"
输出: ["255.255.11.135", "255.255.111.35"]
Related Topics 字符串 回溯算法
[解题源码](_93_RestoreIpAddresses.java)
### 94. Binary Tree Inorder Traversal
题目描述：

&emsp;&emsp;给定一个二叉树，返回它的中序 遍历。

 示例:

 输入: [1,null,2,3]
   1
    \
     2
    /
   3

输出: [1,3,2]

 进阶: 递归算法很简单，你可以通过迭代算法完成吗？
 Related Topics 栈 树 哈希表
[解题源码](_94_BinaryTreeInorderTraversal.java)
### 95. Unique Binary Search Trees II
题目描述：

&emsp;&emsp;给定一个整数 n，生成所有由 1 ... n 为节点所组成的二叉搜索树。

 示例:

 输入: 3
输出:
[
  [1,null,3,2],
  [3,2,null,1],
  [3,1,null,null,2],
  [2,1,3],
  [1,null,2,null,3]
]
解释:
以上的输出对应以下 5 种不同结构的二叉搜索树：

   1         3     3      2      1
    \       /     /      / \      \
     3     2     1      1   3      2
    /     /       \                 \
   2     1         2                 3

 Related Topics 树 动态规划
[解题源码](_95_UniqueBinarySearchTreesIi.java)
### 96. Unique Binary Search Trees
题目描述：

&emsp;&emsp;给定一个整数 n，生成所有由 1 ... n 为节点所组成的二叉搜索树。

 示例:

 输入: 3
输出:
[
  [1,null,3,2],
  [3,2,null,1],
  [3,1,null,null,2],
  [2,1,3],
  [1,null,2,null,3]
]
解释:
以上的输出对应以下 5 种不同结构的二叉搜索树：

   1         3     3      2      1
    \       /     /      / \      \
     3     2     1      1   3      2
    /     /       \                 \
   2     1         2                 3

 Related Topics 树 动态规划
[解题源码](_96_UniqueBinarySearchTrees.java)
### 98. Validate Binary Search Tree
题目描述：

&emsp;&emsp;给定一个二叉树，判断其是否是一个有效的二叉搜索树。

假设一个二叉搜索树具有如下特征：


节点的左子树只包含小于当前节点的数。
节点的右子树只包含大于当前节点的数。
所有左子树和右子树自身必须也是二叉搜索树。


示例 1:

输入:
2
/ \
1   3
输出: true


示例 2:

输入:
5
/ \
1   4
     / \
    3   6
输出: false
解释: 输入为: [5,1,4,null,null,3,6]。
     根节点的值为 5 ，但是其右子节点值为 4 。

Related Topics 树 深度优先搜索
[解题源码](_98_ValidateBinarySearchTree.java)
### 100. Same Tree
题目描述：

&emsp;&emsp;给定两个二叉树，编写一个函数来检验它们是否相同。

 如果两个树在结构上相同，并且节点具有相同的值，则认为它们是相同的。

 示例 1:

 输入:       1         1
          / \       / \
         2   3     2   3

        [1,2,3],   [1,2,3]

输出: true

 示例 2:

 输入:      1          1
          /           \
         2             2

        [1,2],     [1,null,2]

输出: false


 示例 3:

 输入:       1         1
          / \       / \
         2   1     1   2

        [1,2,1],   [1,1,2]

输出: false

 Related Topics 树 深度优先搜索
[解题源码](_100_SameTree.java)
### 101. Symmetric Tree
题目描述：

&emsp;&emsp;给定一个二叉树，检查它是否是镜像对称的。



 例如，二叉树 [1,2,2,3,4,4,3] 是对称的。

     1
   / \
  2   2
 / \ / \
3  4 4  3




 但是下面这个 [1,2,2,null,3,null,3] 则不是镜像对称的:

     1
   / \
  2   2
   \   \
   3    3




 进阶：

 你可以运用递归和迭代两种方法解决这个问题吗？
 Related Topics 树 深度优先搜索 广度优先搜索
[解题源码](_101_SymmetricTree.java)
### 102. Binary Tree Level Order Traversal
题目描述：

&emsp;&emsp;给你一个二叉树，请你返回其按 层序遍历 得到的节点值。 （即逐层地，从左到右访问所有节点）。



 示例：
二叉树：[3,9,20,null,null,15,7],

     3
   / \
  9  20
    /  \
   15   7


 返回其层次遍历结果：

 [
  [3],
  [9,20],
  [15,7]
]

 Related Topics 树 广度优先搜索
[解题源码](_102_BinaryTreeLevelOrderTraversal.java)
### 103. Binary Tree Zigzag Level Order Traversal
题目描述：

&emsp;&emsp;给定一个二叉树，返回其节点值的锯齿形层次遍历。（即先从左往右，再从右往左进行下一层遍历，以此类推，层与层之间交替进行）。

 例如：
给定二叉树 [3,9,20,null,null,15,7],

     3
   / \
  9  20
    /  \
   15   7


 返回锯齿形层次遍历如下：

 [
  [3],
  [20,9],
  [15,7]
]

 Related Topics 栈 树 广度优先搜索
[解题源码](_103_BinaryTreeZigzagLevelOrderTraversal.java)
### 104. Maximum Depth of Binary Tree
题目描述：

&emsp;&emsp;给定一个二叉树，找出其最大深度。

 二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。

 说明: 叶子节点是指没有子节点的节点。

 示例：
给定二叉树 [3,9,20,null,null,15,7]，

     3
   / \
  9  20
    /  \
   15   7

 返回它的最大深度 3 。
 Related Topics 树 深度优先搜索
[解题源码](_104_MaximumDepthOfBinaryTree.java)
### 105. Construct Binary Tree from Preorder and Inorder Traversal
题目描述：

&emsp;&emsp;根据一棵树的前序遍历与中序遍历构造二叉树。

 注意:
你可以假设树中没有重复的元素。

 例如，给出

 前序遍历 preorder = [3,9,20,15,7]
中序遍历 inorder = [9,3,15,20,7]

 返回如下的二叉树：

     3
   / \
  9  20
    /  \
   15   7
 Related Topics 树 深度优先搜索 数组
[解题源码](_105_ConstructBinaryTreeFromPreorderAndInorderTraversal.java)
### 106. Construct Binary Tree from Inorder and Postorder Traversal
题目描述：

&emsp;&emsp;根据一棵树的中序遍历与后序遍历构造二叉树。

 注意:
你可以假设树中没有重复的元素。

 例如，给出

 中序遍历 inorder = [9,3,15,20,7]
后序遍历 postorder = [9,15,7,20,3]

 返回如下的二叉树：

     3
   / \
  9  20
    /  \
   15   7

 Related Topics 树 深度优先搜索 数组
[解题源码](_106_ConstructBinaryTreeFromInorderAndPostorderTraversal.java)
### 107. Binary Tree Level Order Traversal II
题目描述：

&emsp;&emsp;给定一个二叉树，返回其节点值自底向上的层次遍历。 （即按从叶子节点所在层到根节点所在的层，逐层从左向右遍历）

例如：
给定二叉树 [3,9,20,null,null,15,7],

 3
/ \
9  20
/  \
15   7


返回其自底向上的层次遍历为：

[
[15,7],
[9,20],
[3]
]

Related Topics 树 广度优先搜索
[解题源码](_107_BinaryTreeLevelOrderTraversalIi.java)
### 108. Convert Sorted Array to Binary Search Tree
题目描述：

&emsp;&emsp;将一个按照升序排列的有序数组，转换为一棵高度平衡二叉搜索树。

 本题中，一个高度平衡二叉树是指一个二叉树每个节点 的左右两个子树的高度差的绝对值不超过 1。

 示例:

 给定有序数组: [-10,-3,0,5,9],

一个可能的答案是：[0,-3,9,-10,null,5]，它可以表示下面这个高度平衡二叉搜索树：

      0
     / \
   -3   9
   /   /
 -10  5

 Related Topics 树 深度优先搜索
[解题源码](_108_ConvertSortedArrayToBinarySearchTree.java)
### 109. Convert Sorted List to Binary Search Tree
题目描述：

&emsp;&emsp;给定一个单链表，其中的元素按升序排序，将其转换为高度平衡的二叉搜索树。

本题中，一个高度平衡二叉树是指一个二叉树每个节点 的左右两个子树的高度差的绝对值不超过 1。

示例:

给定的有序链表： [-10, -3, 0, 5, 9],

一个可能的答案是：[0, -3, 9, -10, null, 5], 它可以表示下面这个高度平衡二叉搜索树：

  0
 / \
-3   9
/   /
-10  5

Related Topics 深度优先搜索 链表
[解题源码](_109_ConvertSortedListToBinarySearchTree.java)
### 110. Balanced Binary Tree
题目描述：

&emsp;&emsp;给定一个二叉树，判断它是否是高度平衡的二叉树。

 本题中，一棵高度平衡二叉树定义为：


 一个二叉树每个节点 的左右两个子树的高度差的绝对值不超过1。


 示例 1:

 给定二叉树 [3,9,20,null,null,15,7]

     3
   / \
  9  20
    /  \
   15   7

 返回 true 。

示例 2:

 给定二叉树 [1,2,2,3,3,null,null,4,4]

        1
      / \
     2   2
    / \
   3   3
  / \
 4   4


 返回 false 。


 Related Topics 树 深度优先搜索
[解题源码](_110_BalancedBinaryTree.java)
### 112. Path Sum
题目描述：

&emsp;&emsp;给定一个二叉树和一个目标和，判断该树中是否存在根节点到叶子节点的路径，这条路径上所有节点值相加等于目标和。

 说明: 叶子节点是指没有子节点的节点。

 示例:
给定如下二叉树，以及目标和 sum = 22，

               5
             / \
            4   8
           /   / \
          11  13  4
         /  \      \
        7    2      1


 返回 true, 因为存在目标和为 22 的根节点到叶子节点的路径 5->4->11->2。
 Related Topics 树 深度优先搜索
[解题源码](_112_PathSum.java)
### 113. Path Sum II
题目描述：

&emsp;&emsp;给定一个二叉树和一个目标和，找到所有从根节点到叶子节点路径总和等于给定目标和的路径。

 说明: 叶子节点是指没有子节点的节点。

 示例:
给定如下二叉树，以及目标和 sum = 22，

               5
             / \
            4   8
           /   / \
          11  13  4
         /  \    / \
        7    2  5   1


 返回:

 [
   [5,4,11,2],
   [5,8,4,5]
]

 Related Topics 树 深度优先搜索
[解题源码](_113_PathSumIi.java)
### 114. Flatten Binary Tree to Linked List
题目描述：

&emsp;&emsp;给定一个二叉树，原地将它展开为一个单链表。

 例如，给定二叉树

     1
   / \
  2   5
 / \   \
3   4   6

 将其展开为：

 1
 \
  2
   \
    3
     \
      4
       \
        5
         \
          6
 Related Topics 树 深度优先搜索
[解题源码](_114_FlattenBinaryTreeToLinkedList.java)
### 116. Populating Next Right Pointers in Each Node
题目描述：

&emsp;&emsp;给定一个完美二叉树，其所有叶子节点都在同一层，每个父节点都有两个子节点。二叉树定义如下：

 struct Node {
  int val;
  Node *left;
  Node *right;
  Node *next;
}

 填充它的每个 next 指针，让这个指针指向其下一个右侧节点。如果找不到下一个右侧节点，则将 next 指针设置为 NULL。

 初始状态下，所有 next 指针都被设置为 NULL。



 示例：



 输入：{"$id":"1","left":{"$id":"2","left":{"$id":"3","left":null,"next":null,"right":null,"val":4},"next":null,"right":{"$id":"4","left":null,"next":null,"right":null,"val":5},"val":2},"next":null,"right":{"$id":"5","left":{"$id":"6","left":null,"next":null,"right":null,"val":6},"next":null,"right":{"$id":"7","left":null,"next":null,"right":null,"val":7},"val":3},"val":1}

输出：{"$id":"1","left":{"$id":"2","left":{"$id":"3","left":null,"next":{"$id":"4","left":null,"next":{"$id":"5","left":null,"next":{"$id":"6","left":null,"next":null,"right":null,"val":7},"right":null,"val":6},"right":null,"val":5},"right":null,"val":4},"next":{"$id":"7","left":{"$ref":"5"},"next":null,"right":{"$ref":"6"},"val":3},"right":{"$ref":"4"},"val":2},"next":null,"right":{"$ref":"7"},"val":1}

解释：给定二叉树如图 A 所示，你的函数应该填充它的每个 next 指针，以指向其下一个右侧节点，如图 B 所示。




 提示：


 你只能使用常量级额外空间。
 使用递归解题也符合要求，本题中递归程序占用的栈空间不算做额外的空间复杂度。

 Related Topics 树 深度优先搜索
[解题源码](_116_PopulatingNextRightPointersInEachNode.java)
### 117. Populating Next Right Pointers in Each Node II
题目描述：

&emsp;&emsp;给定一个完美二叉树，其所有叶子节点都在同一层，每个父节点都有两个子节点。二叉树定义如下：

 struct Node {
  int val;
  Node *left;
  Node *right;
  Node *next;
}

 填充它的每个 next 指针，让这个指针指向其下一个右侧节点。如果找不到下一个右侧节点，则将 next 指针设置为 NULL。

 初始状态下，所有 next 指针都被设置为 NULL。



 示例：



 输入：{"$id":"1","left":{"$id":"2","left":{"$id":"3","left":null,"next":null,"right":null,"val":4},"next":null,"right":{"$id":"4","left":null,"next":null,"right":null,"val":5},"val":2},"next":null,"right":{"$id":"5","left":{"$id":"6","left":null,"next":null,"right":null,"val":6},"next":null,"right":{"$id":"7","left":null,"next":null,"right":null,"val":7},"val":3},"val":1}

输出：{"$id":"1","left":{"$id":"2","left":{"$id":"3","left":null,"next":{"$id":"4","left":null,"next":{"$id":"5","left":null,"next":{"$id":"6","left":null,"next":null,"right":null,"val":7},"right":null,"val":6},"right":null,"val":5},"right":null,"val":4},"next":{"$id":"7","left":{"$ref":"5"},"next":null,"right":{"$ref":"6"},"val":3},"right":{"$ref":"4"},"val":2},"next":null,"right":{"$ref":"7"},"val":1}

解释：给定二叉树如图 A 所示，你的函数应该填充它的每个 next 指针，以指向其下一个右侧节点，如图 B 所示。




 提示：


 你只能使用常量级额外空间。
 使用递归解题也符合要求，本题中递归程序占用的栈空间不算做额外的空间复杂度。

 Related Topics 树 深度优先搜索
[解题源码](_117_PopulatingNextRightPointersInEachNodeIi.java)
### 118. Pascal's Triangle
题目描述：

&emsp;&emsp;给定一个非负整数 numRows，生成杨辉三角的前 numRows 行。



 在杨辉三角中，每个数是它左上方和右上方的数的和。

 示例:

 输入: 5
输出:
[
     [1],
    [1,1],
   [1,2,1],
  [1,3,3,1],
 [1,4,6,4,1]
]
 Related Topics 数组
[解题源码](_118_PascalsTriangle.java)
### 119. Pascal's Triangle II
题目描述：

&emsp;&emsp;给定一个非负整数 numRows，生成杨辉三角的前 numRows 行。



 在杨辉三角中，每个数是它左上方和右上方的数的和。

 示例:

 输入: 5
输出:
[
     [1],
    [1,1],
   [1,2,1],
  [1,3,3,1],
 [1,4,6,4,1]
]
 Related Topics 数组
[解题源码](_119_PascalsTriangleIi.java)
### 120. Triangle
题目描述：

&emsp;&emsp;给定一个三角形，找出自顶向下的最小路径和。每一步只能移动到下一行中相邻的结点上。

 相邻的结点 在这里指的是 下标 与 上一层结点下标 相同或者等于 上一层结点下标 + 1 的两个结点。



 例如，给定三角形：

 [
     [2],
    [3,4],
   [6,5,7],
  [4,1,8,3]
]


 自顶向下的最小路径和为 11（即，2 + 3 + 5 + 1 = 11）。



 说明：

 如果你可以只使用 O(n) 的额外空间（n 为三角形的总行数）来解决这个问题，那么你的算法会很加分。
 Related Topics 数组 动态规划
[解题源码](_120_Triangle.java)
### 121. Best Time to Buy and Sell Stock
题目描述：

&emsp;&emsp;给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。

 如果你最多只允许完成一笔交易（即买入和卖出一支股票一次），设计一个算法来计算你所能获取的最大利润。

 注意：你不能在买入股票前卖出股票。

 示例 1:

 输入: [7,1,5,3,6,4]
输出: 5
解释: 在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。
     注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格；同时，你不能在买入前卖出股票。


 示例 2:

 输入: [7,6,4,3,1]
输出: 0
解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。

 Related Topics 数组 动态规划
[解题源码](_121_BestTimeToBuyAndSellStock.java)
### 122. Best Time to Buy and Sell Stock II
题目描述：

&emsp;&emsp;给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。

 设计一个算法来计算你所能获取的最大利润。你可以尽可能地完成更多的交易（多次买卖一支股票）。

 注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。



 示例 1:

 输入: [7,1,5,3,6,4]
输出: 7
解释: 在第 2 天（股票价格 = 1）的时候买入，在第 3 天（股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。
     随后，在第 4 天（股票价格 = 3）的时候买入，在第 5 天（股票价格 = 6）的时候卖出, 这笔交易所能获得利润 = 6-3 = 3 。


 示例 2:

 输入: [1,2,3,4,5]
输出: 4
解释: 在第 1 天（股票价格 = 1）的时候买入，在第 5 天 （股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。
     注意你不能在第 1 天和第 2 天接连购买股票，之后再将它们卖出。
     因为这样属于同时参与了多笔交易，你必须在再次购买前出售掉之前的股票。


 示例 3:

 输入: [7,6,4,3,1]
输出: 0
解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。



 提示：


 1 <= prices.length <= 3 * 10 ^ 4
 0 <= prices[i] <= 10 ^ 4

 Related Topics 贪心算法 数组
[解题源码](_122_BestTimeToBuyAndSellStockIi.java)
### 123. Best Time to Buy and Sell Stock III
题目描述：

&emsp;&emsp;给定一个数组，它的第 i 个元素是一支给定的股票在第 i 天的价格。

 设计一个算法来计算你所能获取的最大利润。你最多可以完成 两笔 交易。

 注意: 你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。

 示例 1:

 输入: [3,3,5,0,0,3,1,4]
输出: 6
解释: 在第 4 天（股票价格 = 0）的时候买入，在第 6 天（股票价格 = 3）的时候卖出，这笔交易所能获得利润 = 3-0 = 3 。
     随后，在第 7 天（股票价格 = 1）的时候买入，在第 8 天 （股票价格 = 4）的时候卖出，这笔交易所能获得利润 = 4-1 = 3 。

 示例 2:

 输入: [1,2,3,4,5]
输出: 4
解释: 在第 1 天（股票价格 = 1）的时候买入，在第 5 天 （股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。  
     注意你不能在第 1 天和第 2 天接连购买股票，之后再将它们卖出。  
     因为这样属于同时参与了多笔交易，你必须在再次购买前出售掉之前的股票。


 示例 3:

 输入: [7,6,4,3,1]
输出: 0
解释: 在这个情况下, 没有交易完成, 所以最大利润为 0。
 Related Topics 数组 动态规划
[解题源码](_123_BestTimeToBuyAndSellStockIii.java)
### 125. Valid Palindrome
题目描述：

&emsp;&emsp;给定一个字符串，验证它是否是回文串，只考虑字母和数字字符，可以忽略字母的大小写。

 说明：本题中，我们将空字符串定义为有效的回文串。

 示例 1:

 输入: "A man, a plan, a canal: Panama"
输出: true


 示例 2:

 输入: "race a car"
输出: false

 Related Topics 双指针 字符串
[解题源码](_125_ValidPalindrome.java)
### 127. Word Ladder
题目描述：

&emsp;&emsp;给定两个单词（beginWord 和 endWord）和一个字典，找到从 beginWord 到 endWord 的最短转换序列的长度。转换需遵循如下规则：


 每次转换只能改变一个字母。
 转换过程中的中间单词必须是字典中的单词。


 说明:


 如果不存在这样的转换序列，返回 0。
 所有单词具有相同的长度。
 所有单词只由小写字母组成。
 字典中不存在重复的单词。
 你可以假设 beginWord 和 endWord 是非空的，且二者不相同。


 示例 1:

 输入:
beginWord = "hit",
endWord = "cog",
wordList = ["hot","dot","dog","lot","log","cog"]

输出: 5

解释: 一个最短转换序列是 "hit" -> "hot" -> "dot" -> "dog" -> "cog",
     返回它的长度 5。


 示例 2:

 输入:
beginWord = "hit"
endWord = "cog"
wordList = ["hot","dot","dog","lot","log"]

输出: 0

解释: endWord "cog" 不在字典中，所以无法进行转换。
 Related Topics 广度优先搜索
[解题源码](_127_WordLadder.java)
### 128. Longest Consecutive Sequence
题目描述：

&emsp;&emsp;给定一个未排序的整数数组，找出最长连续序列的长度。

 要求算法的时间复杂度为 O(n)。

 示例:

 输入: [100, 4, 200, 1, 3, 2]
输出: 4
解释: 最长连续序列是 [1, 2, 3, 4]。它的长度为 4。
 Related Topics 并查集 数组
[解题源码](_128_LongestConsecutiveSequence.java)
### 129. Sum Root to Leaf Numbers
题目描述：

&emsp;&emsp;给定一个二叉树，它的每个结点都存放一个 0-9 的数字，每条从根到叶子节点的路径都代表一个数字。

 例如，从根到叶子节点路径 1->2->3 代表数字 123。

 计算从根到叶子节点生成的所有数字之和。

 说明: 叶子节点是指没有子节点的节点。

 示例 1:

 输入: [1,2,3]
    1
   / \
  2   3
输出: 25
解释:
从根到叶子节点路径 1->2 代表数字 12.
从根到叶子节点路径 1->3 代表数字 13.
因此，数字总和 = 12 + 13 = 25.

 示例 2:

 输入: [4,9,0,5,1]
    4
   / \
  9   0
 / \
5   1
输出: 1026
解释:
从根到叶子节点路径 4->9->5 代表数字 495.
从根到叶子节点路径 4->9->1 代表数字 491.
从根到叶子节点路径 4->0 代表数字 40.
因此，数字总和 = 495 + 491 + 40 = 1026.
 Related Topics 树 深度优先搜索
[解题源码](_129_SumRootToLeafNumbers.java)
### 130. Surrounded Regions
题目描述：

&emsp;&emsp;给定一个二维的矩阵，包含 'X' 和 'O'（字母 O）。

 找到所有被 'X' 围绕的区域，并将这些区域里所有的 'O' 用 'X' 填充。

 示例:

 X X X X
X O O X
X X O X
X O X X


 运行你的函数后，矩阵变为：

 X X X X
X X X X
X X X X
X O X X


 解释:

 被围绕的区间不会存在于边界上，换句话说，任何边界上的 'O' 都不会被填充为 'X'。 任何不在边界上，或不与边界上的 'O' 相连的 'O' 最终都会被填充为 'X'。如果两个元素在水平或垂直方向相邻，则称它们是“相连”的。
 Related Topics 深度优先搜索 广度优先搜索 并查集
[解题源码](_130_SurroundedRegions.java)




